# Generates release notes and creates release PR
# - Takes inputs for the release branch, previous and new version, and Android and iOS SDK versions
# - Generates release notes based on the merged PRs since the last release
# - Creates release PR w/ expected release notes

# NOTE: For calls from Native SDKS, do not pass `android_from`, `android_to`, `ios_from`, or `ios_to`
# Use `target_branch` and `release_branch` instead.
name: Create SDK Release

on:
  workflow_call:
    inputs:
      release_branch:
        required: true
        type: string
        description: Name of the release branch
      target_branch:
        required: false
        type: string
        description: The branch to target for the release PR (e.g. 5.4.0-main)
        default: main

      android_from:
        required: false
        type: string
        description: |
          DON'T USE FOR CALLS FROM NATIVE SDKS.
          Android SDK version being updated from.
      android_to:
        required: false
        type: string
        description: |
          DON'T USE FOR CALLS FROM NATIVE SDKS.
          Android SDK version being updated to
      ios_from:
        required: false
        type: string
        description: |
          DON'T USE FOR CALLS FROM NATIVE SDKS.
          iOS SDK version being updated from.
      ios_to:
        required: false
        type: string
        description: |
          DON'T USE FOR CALLS FROM NATIVE SDKS.
          iOS SDK version being updated to.

jobs:
  create_release:
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ github.token }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.target_branch }}
          fetch-depth: 0

      - name: Extract version_to from release_branch
        id: release_version
        run: |
          # Extract version from release_branch format: rel/version_to
          VERSION_TO="${{ inputs.release_branch }}"
          VERSION_TO="${VERSION_TO#rel/}"
          echo "version_to=$VERSION_TO" >> $GITHUB_OUTPUT

      - name: Get last release commit
        id: last_commit
        run: |
          # Get the last tag from the target branch (already checked out)
          CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null) || {
            # Fallback to first commit if no tags
            git rev-list --max-parents=0 HEAD
          }
          LAST_RELEASE_DATE=$(git show -s --format=%cI "$CURRENT_VERSION")
          echo "date=$LAST_RELEASE_DATE" >> $GITHUB_OUTPUT

      - name: Get merged PRs
        id: get_prs
        uses: actions/github-script@v8
        with:
          script: |
            const lastReleaseDate = '${{ steps.last_commit.outputs.date }}';
            const releaseBranch = '${{ inputs.release_branch }}';
            const targetBranch = '${{ inputs.target_branch }}';
            const version = '${{ steps.release_version.outputs.version_to }}';

            // Get the creation date of the release branch (when it diverged from main)
            const { data: branchInfo } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: releaseBranch
            });
            const branchCreatedAt = branchInfo.commit.commit.committer.date;

            // Get PRs merged to target branch since last release
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              base: targetBranch,
              per_page: 100
            });

            const mergedPrs = prs
              .filter(pr =>
                pr.merged_at &&
                new Date(pr.merged_at) > new Date(lastReleaseDate)
              )
              .map(pr => ({
                number: pr.number,
                title: pr.title,
              }));
            core.setOutput('prs', JSON.stringify(mergedPrs));

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v8
        with:
          script: |
            // Trim whitespace from PR titles
            const prs = JSON.parse('${{ steps.get_prs.outputs.prs }}').map(pr => ({
              ...pr,
              title: pr.title.trim()
            }));

            // Categorize PRs (exclude internal changes like ci/chore)
            const features = prs.filter(pr => /^feat/i.test(pr.title));
            const fixes = prs.filter(pr => /^fix/i.test(pr.title));
            const improvements = prs.filter(pr => /^(perf|refactor)/i.test(pr.title));

            // Helper function to build section
            const buildSection = (title, prs) => {
              if (prs.length === 0) return '';
              let section = `### ${title}\n\n`;
              prs.forEach(pr => {
                section += `- ${pr.title} (#${pr.number})\n`;
              });
              return section + '\n';
            };

            // Parse version strings handling semantic versioning with prerelease tags
            const parseVersion = (v) => {
              // Handle versions like "5.1.36", "5.1.36-alpha", "5.1.36-beta", "5.1.36-alpha.1", etc.
              const parts = v.split('-');
              const baseVersion = parts[0].split('.').map(Number);
              const prerelease = parts[1] || '';
              
              return { baseVersion, prerelease };
            };

            // Compare two versions considering base version and prerelease tags
            const compareVersions = (v1, v2) => {
              const ver1 = parseVersion(v1);
              const ver2 = parseVersion(v2);
              
              // Compare base versions first
              const base1 = ver1.baseVersion;
              const base2 = ver2.baseVersion;
              
              for (let i = 0; i < Math.max(base1.length, base2.length); i++) {
                const a = base1[i] || 0;
                const b = base2[i] || 0;
                if (a !== b) return a - b;
              }
              
              // Base versions are equal, compare prerelease
              // No prerelease (stable) > any prerelease
              if (!ver1.prerelease && !ver2.prerelease) return 0;
              if (!ver1.prerelease) return 1; // v1 is stable, v2 is prerelease
              if (!ver2.prerelease) return -1; // v2 is stable, v1 is prerelease
              
              // Both have prerelease, compare them lexicographically
              return ver1.prerelease.localeCompare(ver2.prerelease);
            };

            // Helper function to fetch and format native SDK release notes e.g.
            // Update Android SDK from 5.1.33 to 5.1.34
            // fix: ... ([OneSignal-Android-SDK#some-number](https://github.com/OneSignal/OneSignal-Android-SDK/pull/some-number))
            const fetchNativeSDKReleaseNotes = async (fromVersion, toVersion, owner, repo) => {
              try {
                // Fetch all releases
                const { data: allReleases } = await github.rest.repos.listReleases({
                  owner,
                  repo,
                  per_page: 100
                });
                
                // Filter releases between fromVersion and toVersion
                const relevantReleases = allReleases
                  .filter(release => {
                    const tagVersion = release.tag_name;
                    const cmp1 = compareVersions(tagVersion, fromVersion);
                    const cmp2 = compareVersions(tagVersion, toVersion);
                    // Include releases > from and <= to
                    return cmp1 > 0 && cmp2 <= 0;
                  })
                  .sort((a, b) => compareVersions(b.tag_name, a.tag_name)); // Sort descending by version
                
                // Extract bullet points from each release
                let notes = '';
                relevantReleases.forEach(release => {
                  const body = release.body || '';
                  // Extract bullet points (lines starting with - or *)
                  const bullets = body
                    .split('\n')
                    .filter(line => /^\s*[-*]\s/.test(line))
                    .map(line => line.replace(/^\s*[-*]\s/, '').trim())
                    .map(line => {
                      // Convert PR references (#123) to full GitHub links
                      return line.replace(/\(#(\d+)\)/g, `([${repo}#$1](https://github.com/${owner}/${repo}/pull/$1))`);
                    })
                    .filter(line => line.length > 0);
                  
                  if (bullets.length > 0) {
                    bullets.forEach(bullet => {
                      notes += `  - ${bullet}\n`;
                    });
                  }
                });
                return notes;
              } catch (error) {
                core.warning(`Failed to fetch ${repo} release notes: ${error.message}`);
                return '';
              }
            };

            // Determine release type from version
            const version = '${{ steps.release_version.outputs.version_to }}';
            const releaseType = version.includes('-alpha') ? 'Alpha' : 
                               version.includes('-beta') ? 'Beta' : 'Current';

            let releaseNotes = `Channels: ${releaseType}\n\n`;
            releaseNotes += buildSection('ðŸš€ New Features', features);
            releaseNotes += buildSection('ðŸ› Bug Fixes', fixes);
            releaseNotes += buildSection('âœ¨ Improvements', improvements);

            // Check for native dependency changes
            const androidFrom = '${{ inputs.android_from }}';
            const androidTo = '${{ inputs.android_to }}';
            const iosFrom = '${{ inputs.ios_from }}';
            const iosTo = '${{ inputs.ios_to }}';
            const hasAndroidUpdate = androidFrom && androidTo;
            const hasIosUpdate = iosFrom && iosTo;

            if (hasAndroidUpdate || hasIosUpdate) {
              releaseNotes += '\n### ðŸ› ï¸ Native Dependency Updates\n\n';
              if (hasAndroidUpdate) {
                releaseNotes += `- Update Android SDK from ${androidFrom} to ${androidTo}\n`;
                releaseNotes += await fetchNativeSDKReleaseNotes(androidFrom, androidTo, 'OneSignal', 'OneSignal-Android-SDK');
              }
              if (hasIosUpdate) {
                releaseNotes += `- Update iOS SDK from ${iosFrom} to ${iosTo}\n`;
                releaseNotes += await fetchNativeSDKReleaseNotes(iosFrom, iosTo, 'OneSignal', 'OneSignal-iOS-SDK');
              }
              releaseNotes += '\n';
            }

            core.setOutput('notes', releaseNotes);

      - name: Create release PR
        run: |
          # Checkout the release branch
          git checkout ${{ inputs.release_branch }}

          NEW_VERSION="${{ steps.release_version.outputs.version_to }}"
          TARGET_BRANCH="${{ inputs.target_branch }}"

          # Write release notes to file to avoid shell interpretation
          cat > release_notes.md << 'EOF'
          ${{ steps.release_notes.outputs.notes }}
          EOF

          gh pr create \
            --title "chore: Release $NEW_VERSION" \
            --body-file release_notes.md \
            --base "$TARGET_BRANCH"
