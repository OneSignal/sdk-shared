# Generates release notes and creates release PR
name: Create Release

on:
  workflow_call:
    inputs:
      release_branch:
        required: true
        type: string
        description: Name of the release branch
      version_from:
        required: true
        type: string
        description: The previous version (e.g., 5.2.14)
      version_to:
        required: true
        type: string
        description: The new version being released (e.g., 5.2.15)

      android_from:
        required: false
        type: string
        description: Android SDK version being updated from
      android_to:
        required: false
        type: string
        description: Android SDK version being updated to
      ios_from:
        required: false
        type: string
        description: iOS SDK version being updated from
      ios_to:
        required: false
        type: string
        description: iOS SDK version being updated to

jobs:
  create_release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Get last release commit
        id: last_commit
        run: |
          CURRENT_VERSION="${{ inputs.version_from }}"
          LAST_RELEASE_DATE=$(git show -s --format=%cI "$CURRENT_VERSION")
          echo "date=$LAST_RELEASE_DATE" >> $GITHUB_OUTPUT

      - name: Get merged PRs
        id: get_prs
        uses: actions/github-script@v8
        with:
          script: |
            const lastReleaseDate = '${{ steps.last_commit.outputs.date }}';
            const releaseBranch = '${{ inputs.release_branch }}';
            const version = '${{ inputs.version_to }}';

            // Determine release type from version
            const releaseType = version.includes('-alpha') ? 'Alpha' : 
                               version.includes('-beta') ? 'Beta' : 'Current';

            // Get the creation date of the release branch (when it diverged from main)
            const { data: branchInfo } = await github.rest.repos.getBranch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: releaseBranch
            });
            const branchCreatedAt = branchInfo.commit.commit.committer.date;


            // For Current: Get PRs merged to main since last release but BEFORE release branch was created
            // For Alpha/Beta: Use releaseBranch as base
            const baseBranch = (releaseType === 'Alpha' || releaseType === 'Beta') ? releaseBranch : 'main';
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              base: baseBranch,
              per_page: 100
            });

            const mergedPrs = prs
              .filter(pr =>
                pr.merged_at &&
                new Date(pr.merged_at) > new Date(lastReleaseDate) &&
                (releaseType === 'Current' ? new Date(pr.merged_at) <= new Date(branchCreatedAt) : true)
              )
              .map(pr => ({
                number: pr.number,
                title: pr.title,
              }));
            core.setOutput('prs', JSON.stringify(mergedPrs));

      - name: Generate release notes
        id: release_notes
        uses: actions/github-script@v8
        with:
          script: |
            // Trim whitespace from PR titles
            const prs = JSON.parse('${{ steps.get_prs.outputs.prs }}').map(pr => ({
              ...pr,
              title: pr.title.trim()
            }));

            // Categorize PRs (exclude internal changes like ci/chore)
            const features = prs.filter(pr => /^feat/i.test(pr.title));
            const fixes = prs.filter(pr => /^fix/i.test(pr.title));
            const improvements = prs.filter(pr => /^(perf|refactor)/i.test(pr.title));

            // Helper function to build section
            const buildSection = (title, prs) => {
              if (prs.length === 0) return '';
              let section = `### ${title}\n\n`;
              prs.forEach(pr => {
                section += `- ${pr.title} (#${pr.number})\n`;
              });
              return section + '\n';
            };

            // Determine release type from version
            const version = '${{ inputs.version_to }}';
            const releaseType = version.includes('-alpha') ? 'Alpha' : 
                               version.includes('-beta') ? 'Beta' : 'Current';

            let releaseNotes = `Channels: ${releaseType}\n\n`;
            releaseNotes += buildSection('ðŸš€ New Features', features);
            releaseNotes += buildSection('ðŸ› Bug Fixes', fixes);
            releaseNotes += buildSection('âœ¨ Improvements', improvements);

            // Check for native dependency changes
            const androidFrom = '${{ inputs.android_from }}';
            const androidTo = '${{ inputs.android_to }}';
            const iosFrom = '${{ inputs.ios_from }}';
            const iosTo = '${{ inputs.ios_to }}';
            const hasAndroidUpdate = androidFrom && androidTo;
            const hasIosUpdate = iosFrom && iosTo;

            if (hasAndroidUpdate || hasIosUpdate) {
              releaseNotes += '\n### ðŸ› ï¸ Native Dependency Updates\n\n';
              if (hasAndroidUpdate) {
                releaseNotes += `- Update Android SDK from ${androidFrom} to ${androidTo}\n`;
                releaseNotes += `  - See [release notes](https://github.com/OneSignal/OneSignal-Android-SDK/releases) for full details\n`;
              }
              if (hasIosUpdate) {
                releaseNotes += `- Update iOS SDK from ${iosFrom} to ${iosTo}\n`;
                releaseNotes += `  - See [release notes](https://github.com/OneSignal/OneSignal-iOS-SDK/releases) for full details\n`;
              }
              releaseNotes += '\n';
            }

            core.setOutput('notes', releaseNotes);

      - name: Create release PR
        run: |
          NEW_VERSION="${{ inputs.version_to }}"

          # Determine release type and base branch from version
          if [[ "$NEW_VERSION" =~ -alpha ]]; then
            BASE_BRANCH="${{ inputs.release_branch }}"
          elif [[ "$NEW_VERSION" =~ -beta ]]; then
            BASE_BRANCH="${{ inputs.release_branch }}"
          else
            BASE_BRANCH="main"
          fi

          # Write release notes to file to avoid shell interpretation
          cat > release_notes.md << 'EOF'
          ${{ steps.release_notes.outputs.notes }}
          EOF

          gh pr create \
            --title "chore: Release $NEW_VERSION" \
            --body-file release_notes.md \
            --base "$BASE_BRANCH"
